const axios = require('axios');

let express = require('express');
let cors = require('cors')
const bodyParser = require('body-parser');

let allTracks = []
let allTracksLengthSeconds = 0
let requiredTotalLengthMins = 0

const uploadTracks = async (masterTracks, access_token, name) => {
    // Create playlist
    let playlist = await createPlaylist(access_token, name);
    // Add tracks to playlist
    await addTracksToPlaylist(masterTracks, playlist.id, access_token);
    // Return Spotify URL of playlist
    return playlist.external_urls.spotify;
}
  
const addTracksToPlaylist = async (masterTracks, playlistId, access_token) => {
    // Iterate through masterTracks by 100's and upload tracks to playlist
    let i = 0;
    let numTracks = masterTracks.length;
    let count = 0;
    let tracksArray = [];
    while (i < numTracks) {
        tracksArray.push(masterTracks[i].uri);
        i++;
        count++;
        if (count == 100 || i == numTracks) {
            console.log('Adding tracks up to #' + i);
            //console.log(tracks)
            //let snapshotId = await postSetOfTracks(tracks, playlistId, access_token)
            let snapshotId = await postSetOfTracks(tracksArray, playlistId, access_token);
            tracksArray = [];
            count = 0;
            console.log('Completed: ', snapshotId.snapshot_id);
        }
        //console.log(count)
    }
}
  
const postSetOfTracks = async (tracks, playlistId, access_token) => {
    let url = 'https://api.spotify.com/v1/playlists/' + playlistId + '/tracks';
    //console.log(url)
    let params = {
        uris: tracks
    };
    //console.log(params)
    let config = {
        headers: { 'Authorization': 'Bearer ' + access_token },
    };
    let resp = await axios.post(url, params, config);
    //console.log('posted: ' + resp.data)
    return resp.data;
}
  
const createPlaylist = async (access_token, name = 'VibeSet Playlist') => {
    // Get current user ID
    let userId = await getUserId(access_token);
    console.log('User ID: ', userId);
    // Make API call to create playlist using url, userId, and name
    let url = 'https://api.spotify.com/v1/users/' + userId + '/playlists';
    let params = {
        name: name,
        description: 'This playlist was generated by VibeSet.'
    };
    let config = {
        headers: { 'Authorization': 'Bearer ' + access_token }
    };
    let resp = await axios.post(url, params, config);
    let newPlaylist = resp.data;
    let spotifyURL = newPlaylist.external_urls.spotify;
    //console.log('Playlist URL: ', spotifyURL)
    return newPlaylist;
}
  
const getUserId = async (access_token) => {
    // Make API call to return userId
    let url = 'https://api.spotify.com/v1/me';
    let config = {
        headers: { 'Authorization': 'Bearer ' + access_token }
    };
    let resp = await axios.get(url, config);
    let data = resp.data;
    return data.id;
}

const sortAllTracks = (rawTracks, checkpoints) => {
    // Construct regions from checkpoints
    let regions = constructRegions(checkpoints);
    // Construct trackHolder from rawTracks
    let trackHolder = constructTrackHolder(rawTracks, regions);
    // Distribute tracks into regions by trackInterval
    regions = distributeTracksIntoRegions(trackHolder, regions);
    // Sort each region's tracks according to its vibeLevelRange
    regions = sortRegionTracks(regions);
    // Append each region's tracks to a master track list and return
    let masterTracks = constructMasterTracklist(regions);
    return masterTracks;
}

const constructRegions = (checkpoints) => {
    let regions = [];
    numCheckpoints = checkpoints.length;
    for (let i = 0; i < numCheckpoints - 1; i++) {
        let left = checkpoints[i];
        let right = checkpoints[i + 1];
        newRegion = {
            timeEndpoints: [left.location, right.location],
            vibeLevelRange: [left.vibeLevel, right.vibeLevel],
            timeLength: 0,
            tracks: []
        };
        regions.push(newRegion);
    }
    //console.log(regions)
    return regions;
}
  
const constructTrackHolder = (rawTracks, regions) => {
    // Initialize variables
    let trackHolder = [];
    let numTotalTracks = rawTracks.length;
    let tenthTrack = Math.floor(numTotalTracks / 9);
    // [0, 1] [1, 2] [2, 3] [3, 4] [4, 5] [5, 6] [6, 7] [7, 8] [8, 9] [9, 10]
    for (let totalCounter = 0; totalCounter < 9; totalCounter++) {
        // Construct current interval
        let currTrackInterval = {
            endpoints: [totalCounter+1, totalCounter+2],
            tracks: [],
            eligibleRegions: []
        };
        // Add tracks
        for (let currCounter = 0; currCounter < tenthTrack; currCounter++) {
            let currIndex = (totalCounter * tenthTrack) + currCounter;
            currTrackInterval.tracks.push(rawTracks[currIndex]);
        }
        // Iterate through regions and add those w/correct vibeLevelRange to eligibleRegions
        regions.forEach(function (region) {
            let lowerLevel = Math.min(...region.vibeLevelRange);
            let upperLevel = Math.max(...region.vibeLevelRange);
            if (currTrackInterval.endpoints[0] >= lowerLevel && currTrackInterval.endpoints[1] <= upperLevel) {
                currTrackInterval.eligibleRegions.push(region);
            }
        });
        trackHolder.push(currTrackInterval);
    }
    //console.log(trackHolder)
    return trackHolder;
}
  
const distributeTracksIntoRegions = (trackHolder, regions) => {
    let maxNumTracks = 0;
    trackHolder.forEach(function (currInterval) {
        maxNumTracks = Math.max(maxNumTracks, currInterval.tracks.length);
    });
    for (let i = 0; i < maxNumTracks; i++) {
        trackHolder.forEach(function (currInterval) {
            if (i >= currInterval.tracks.length) {
                return;
            }
            //console.log('Interval: ', currInterval.endpoints)
            let numEligibleRegions = currInterval.eligibleRegions.length;
            let numTracks = currInterval.tracks.length;
            if (numEligibleRegions > 0) {
                // Add current track to currently selected eligible region
                let currTrack = currInterval.tracks[i];
                let currRegionIndex = i % numEligibleRegions;
                let currRegion = currInterval.eligibleRegions[currRegionIndex];
                // Keep track of current region's length
                //console.log(currRegion.timeEndpoints[0], currRegion.timeEndpoints[1], requiredTotalLengthMins)
                let requiredDuration = Math.abs(currRegion.timeEndpoints[0] - currRegion.timeEndpoints[1]) / 10 * requiredTotalLengthMins;
                if (currRegion.timeLength >= requiredDuration) {
                    currInterval.eligibleRegions.splice(currRegionIndex, 1);
                    numEligibleRegions--;
                }
                else {
                    currRegion.tracks.push(currTrack);
                    currRegion.timeLength += currTrack.duration_ms / 1000 / 60;
                }
                //console.log(currRegion.timeEndpoints, ': ', currRegion.timeLength, ' ', requiredDuration)
            }
        });
    }
    console.log(regions);
    return regions;
}
  
const sortRegionTracks = (regions) => {
    regions.forEach(function (region) {
        let order = 'asc';
        if (region.vibeLevelRange[0] > region.vibeLevelRange[1]) {
            order = 'desc';
        }
        region.tracks = sortRegion(region.tracks, order, name = '', log = true);
    });
    return regions;
}
  
const constructMasterTracklist = (regions) => {
    let masterTracks = [];
    regions.forEach(function (region) {
        masterTracks = masterTracks.concat(region.tracks);
    });
    return masterTracks;
}

const logTracks = (tracks) => {
    console.log('---------------');
    console.log('Logging tracks:');
    tracks.forEach(function (track) {
        console.log(track.name + ' ' + track.vibeLevelNorm);
    });
    console.log('---------------');
}

// Sort a region of tracks
const sortRegion = (tracks, order, name='', log=false) => {
    var sorted = tracks
    if (order == 'desc') {
      sorted = sorted.sort((a, b) => b.vibeLevelNorm-a.vibeLevelNorm);
    }
    else if (order == 'asc') {
      sorted = sorted.sort((a, b) => a.vibeLevelNorm-b.vibeLevelNorm);
    }
    if(log) {
      console.log('----------------------')
      console.log('Logging sorted region ' + name + ':')
      sorted.forEach(function(track) {
        console.log(track.name + ' ' + track.vibeLevelNorm)
      })
      console.log('----------------------')
    }
    return sorted
}

// Compute vibeLevel heuristic for each track
const computeVibeLevels = () => {
    console.log('------------------')
    console.log('Computing vibe levels:')
    // Statistics
    let minVibe = 1
    let maxVibe = 0
    let avgVibe = 0
    let minSong = ''
    let maxSong = ''
    let everyOther = 17
    let count = 0
    allTracks.forEach(function(item) {
      let audioFeats = item['audio_features']
      // Basic energy [0-1] + danceability [0-1]
      let basicMult = 0.8
      let vibeLevel = (audioFeats['energy'] + audioFeats['danceability']) / 2 * basicMult
      // Loudness [-60db-0db]
      let loudnessMult = 0.5
      vibeLevel += (audioFeats['loudness'] + 30) / 60 * loudnessMult
      // Valence [0-1]
      let valenceMult = 0.3
      vibeLevel += (audioFeats['valence'] - 0.7) * valenceMult
      // Clamp
      if (vibeLevel > 0.999) {
        vibeLevel = 0.999
      }
      else if (vibeLevel < 0.001) {
        vibeLevel = 0.001
      }
      // Find max and min
      if (vibeLevel < minVibe) {
        minVibe = vibeLevel
        minSong = item['name']
      }
      if (vibeLevel > maxVibe) {
        maxVibe = vibeLevel
        maxSong = item['name']
      }
      item['vibeLevel'] = vibeLevel
      avgVibe += vibeLevel
      allTracksLengthSeconds += item.duration_ms / 1000
    })
    avgVibe /= allTracks.length
    // Print stats
    console.log('min vibe: ' + minVibe + ' ' + minSong)
    console.log('max vibe: ' + maxVibe + ' ' + maxSong)
    console.log('avg vibe: ' + avgVibe)
    normalizeVibeLevels(minVibe, maxVibe)
}

// Normalize vibeLevels (0-100) of each track
const normalizeVibeLevels = (minVibe, maxVibe) => {
    allTracks.forEach(function(track) {
      vibeLevel = track['vibeLevel']
      vibeLevelNormalized = (vibeLevel - minVibe) / (maxVibe - minVibe) * 100
      track['vibeLevelNorm'] = vibeLevelNormalized
    })
}

// Get raw set of tracks using seed genres and required length
const getTrackRecommendations = async (access_token, seedGenres, length, currLength, tracks) => {
    let url = 'https://api.spotify.com/v1/recommendations'
    let config = {
      headers: { 'Authorization': 'Bearer ' + access_token },
      params: {
        seed_genres: seedGenres,
        limit: 100
      }
    }
    console.log('Getting track recs at URL: ' + url)
    let resp = await axios.get(url, config)
    let body = resp.data
    let newTracks = body.tracks
    //console.log(tracks)
    let nonOverlap = newTracks.filter(a => !tracks.some(b => a.id === b.id));
    parsed = await parseTracks(nonOverlap, {url: url, config: config})
    currLength += parsed[0]
    tracks = tracks.concat(parsed[1])
    if (currLength < length * 2) { // Grab double required length of tracks for filtering
      return await getTrackRecommendations(access_token, seedGenres, length, currLength, tracks);
    }
    else {
      return tracks
    }
}

// Parse a set of tracks, choosing for correct genre and adding audio features
const parseTracks =  async (tracks, options) => {
    let currLength = 0
    let newTracks = []
    let trackIDs = ''
    tracks.forEach(function(track) {
      // Check for correct genre
      //console.log(track.name)
      currLength += track['duration_ms']
      newTracks.push(track)
      trackIDs += track['id'] + ','
    })
    // Query track's audio features
    trackIDs = trackIDs.slice(0, -1)
    options['url'] = 'https://api.spotify.com/v1/audio-features'
    options['config']['params'] = {'ids': trackIDs}
    let resp = await axios.get(options['url'], options['config'])
    let body = resp['data']
    let i = 0
    body['audio_features'].forEach(function(item){
      newTracks[i]['audio_features'] = item
      i += 1
    })
    currLength = currLength / 1000 / 60
    return [currLength, newTracks]
  }

let app = express();
app.use(cors())
app.use(bodyParser.json());

app.post('/', async function(req, res) {
    console.log(req.body.input)
    const accessToken = req.body.input.accessToken
    const name = req.body.input.name
    const length = req.body.input.length
    const genres = req.body.input.genres
    const checkpoints = req.body.input.checkpoints

    requiredTotalLengthMins = length
    allTracks = await getTrackRecommendations(accessToken, genres, length, 0, [])

    computeVibeLevels()

    // Sort in decreasing order
    sortRegion(allTracks, 'asc', 'allTracks', log=false)

    let masterTracks = sortAllTracks(allTracks, checkpoints)
    logTracks(masterTracks)

    let shareableURL = await uploadTracks(masterTracks, accessToken, name)
    console.log('Playlist created: ', shareableURL)

    res.json({
        message: 'Success!',
        playlistURL: shareableURL
    })
});

module.exports = app;